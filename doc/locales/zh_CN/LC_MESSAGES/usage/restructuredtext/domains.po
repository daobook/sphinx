# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2021, Georg Brandl and the Sphinx team
# This file is distributed under the same license as the Sphinx package.
# xinetzone <735613050@qq.com>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sphinx 4.2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-09 10:05+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: xinetzone <735613050@qq.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../usage/restructuredtext/domains.rst:5
msgid "Domains"
msgstr "域"

#: ../../usage/restructuredtext/domains.rst:9
msgid ""
"Originally, Sphinx was conceived for a single project, the documentation "
"of the Python language.  Shortly afterwards, it was made available for "
"everyone as a documentation tool, but the documentation of Python modules"
" remained deeply built in -- the most fundamental directives, like "
"``function``, were designed for Python objects.  Since Sphinx has become "
"somewhat popular, interest developed in using it for many different "
"purposes: C/C++ projects, JavaScript, or even reStructuredText markup "
"(like in this documentation)."
msgstr ""
"最初，Sphinx 是为一个单一的项目设想的，即 Python 语言的文档。不久之后，它作为一个文档工具提供给所有人，但 Python "
"模块的文档仍然深深地内置于其中--最基本的指令，如 ``function``，是为 Python 对象设计的。由于 Sphinx "
"已经变得有些流行，人们对将其用于许多不同的目的产生了兴趣：C/C++ 项目，JavaScript，甚至是 reStructuredText "
"标记（比如这个文档）。"

#: ../../usage/restructuredtext/domains.rst:17
msgid ""
"While this was always possible, it is now much easier to easily support "
"documentation of projects using different programming languages or even "
"ones not supported by the main Sphinx distribution, by providing a "
"**domain** for every such purpose."
msgstr ""
"虽然这一直是可能的，但现在通过为每一个这样的目的提供一个 **域**，可以更容易地支持使用不同编程语言的项目的文档，甚至是主要的 Sphinx "
"发行版不支持的项目。"

#: ../../usage/restructuredtext/domains.rst:22
msgid ""
"A domain is a collection of markup (reStructuredText :term:`directive`\\ "
"s and :term:`role`\\ s) to describe and link to :term:`object`\\ s "
"belonging together, e.g. elements of a programming language.  Directive "
"and role names in a domain have names like ``domain:name``, e.g. "
"``py:function``.  Domains can also provide custom indices (like the "
"Python Module Index)."
msgstr ""
"域是一个标记的集合（reStructuredText :term:`指令` 和 :term:`角色`），用来描述和链接属于一起的 "
":term:`对象`，例如，编程语言的元素。域中的指令和角色名称有类似 ``domain:name`` 的名称，例如 "
"``py:function``。域也可以提供自定义索引（如 Python 模块索引）。"

#: ../../usage/restructuredtext/domains.rst:28
msgid ""
"Having domains means that there are no naming problems when one set of "
"documentation wants to refer to e.g. C++ and Python classes.  It also "
"means that extensions that support the documentation of whole new "
"languages are much easier to write."
msgstr "拥有域意味着当一组文档想要引用例如 C++ 和 Python 类时，不会出现命名问题。这也意味着支持整个新语言的文档的扩展更容易编写。"

#: ../../usage/restructuredtext/domains.rst:33
msgid ""
"This section describes what the domains that are included with Sphinx "
"provide. The domain API is documented as well, in the section :ref"
":`domain-api`."
msgstr "本节描述了包括在 Sphinx 中的域所提供的东西。域的 API 也被记录在 :ref:`domain-api` 部分。"

#: ../../usage/restructuredtext/domains.rst:40
msgid "Basic Markup"
msgstr "基础标记"

#: ../../usage/restructuredtext/domains.rst:42
msgid ""
"Most domains provide a number of :dfn:`object description directives`, "
"used to describe specific objects provided by modules.  Each directive "
"requires one or more signatures to provide basic information about what "
"is being described, and the content should be the description.  A domain "
"will typically keep an internal index of all entities to aid cross-"
"referencing. Typically it will also add entries in the shown general "
"index. If you want to suppress the addition of an entry in the shown "
"index, you can give the directive option flag ``:noindexentry:``. If you "
"want to typeset an object description, without even making it available "
"for cross-referencing, you can give the directive option flag "
"``:noindex:`` (which implies ``:noindexentry:``). Though, note that not "
"every directive in every domain may support these options."
msgstr ""
"大多数域提供了一些 :dfn:`object description "
"directives`，用于描述模块提供的特定对象。每个指令都需要一个或多个签名，以提供关于被描述的内容的基本信息，而内容应该是描述。一个域通常会保留一个所有实体的内部索引以帮助交叉引用。通常，它也会在显示的一般索引中添加条目。如果你想抑制在显示的索引中添加条目，你可以给指令的选项标志"
" ``:noindexentry:``。如果你想排版一个对象的描述，甚至不使其可用于交叉引用，你可以给指令选项标志 ``:noindex:`` "
"（这意味着 ``:noindexentry:``）。不过，请注意，不是每个域的每个指令都可能支持这些选项。"

#: ../../usage/restructuredtext/domains.rst:56
msgid ""
"The directive option ``noindexentry`` in the Python, C, C++, and "
"Javascript domains."
msgstr "Python、C、C++ 和 Javascript 域的指令选项 ``noindexentry``。"

#: ../../usage/restructuredtext/domains.rst:60
msgid "An example using a Python domain directive::"
msgstr "一个使用 Python 域指令的例子 ::"

#: ../../usage/restructuredtext/domains.rst:67
msgid ""
"This describes the two Python functions ``spam`` and ``ham``.  (Note that"
" when signatures become too long, you can break them if you add a "
"backslash to lines that are continued in the next line.  Example::"
msgstr ""
"这描述了两个 Python 函数 ``spam`` 和 "
"``ham``。（注意，当签名变得太长时，如果你在下一行继续的行中添加反斜杠，就可以将其断开。例如 ::"

#: ../../usage/restructuredtext/domains.rst:75
msgid "(This example also shows how to use the ``:noindex:`` flag.)"
msgstr "（这个例子也显示了如何使用 ``:noindex:`` 旗标）。"

#: ../../usage/restructuredtext/domains.rst:77
msgid ""
"The domains also provide roles that link back to these object "
"descriptions. For example, to link to one of the functions described in "
"the example above, you could say ::"
msgstr "域还提供了链接到这些对象描述的角色。例如，要链接到上面例子中描述的一个函数，你可以 ::"

#: ../../usage/restructuredtext/domains.rst:83
msgid ""
"As you can see, both directive and role names contain the domain name and"
" the directive name."
msgstr "正如你所看到的，指令和角色名称都包含域名和指令名称。"

#: ../../usage/restructuredtext/domains.rst:87
msgid "Default Domain"
msgstr "默认域"

#: ../../usage/restructuredtext/domains.rst:88
msgid ""
"For documentation describing objects from solely one domain, authors will"
" not have to state again its name at each directive, role, etc... after "
"having specified a default. This can be done either via the config value "
":confval:`primary_domain` or via this directive:"
msgstr ""
"对于只描述一个域的对象的文档，作者不必在指定了默认值后，在每个指令、角色等处再次说明其名称。这可以通过配置值 "
":confval:`primary_domain` 或者通过这个指令来实现："

#: ../../usage/restructuredtext/domains.rst:95
msgid ""
"Select a new default domain.  While the :confval:`primary_domain` selects"
" a global default, this only has an effect within the same file."
msgstr "选择一个新的默认域。虽然 :confval:`primary_domain` 选择了一个全局默认，但这只在同一文件内有影响。"

#: ../../usage/restructuredtext/domains.rst:98
msgid ""
"If no other default is selected, the Python domain (named ``py``) is the "
"default one, mostly for compatibility with documentation written for "
"older versions of Sphinx."
msgstr "如果没有选择其他默认，Python 域（命名为 ``py``）是默认的，主要是为了与为旧版本的 Sphinx 编写的文档兼容。"

#: ../../usage/restructuredtext/domains.rst:102
msgid ""
"Directives and roles that belong to the default domain can be mentioned "
"without giving the domain name, i.e. ::"
msgstr "属于默认域的指令和角色可以不给出域名而被提及，即 ::"

#: ../../usage/restructuredtext/domains.rst:112
msgid "Cross-referencing syntax"
msgstr "交叉引用的语法"

#: ../../usage/restructuredtext/domains.rst:114
msgid ""
"For cross-reference roles provided by domains, the same facilities exist "
"as for general cross-references.  See :ref:`xref-syntax`."
msgstr "对于由域提供的交叉引用角色，存在与一般交叉引用相同的设施。参见 :ref:`xref-syntax`。"

#: ../../usage/restructuredtext/domains.rst:117
msgid "In short:"
msgstr "简而言之："

#: ../../usage/restructuredtext/domains.rst:119
msgid ""
"You may supply an explicit title and reference target: ``:role:`title "
"<target>``` will refer to *target*, but the link text will be *title*."
msgstr "你可以提供一个明确的标题和参考目标：``:role:`title <target>``` 将引用 *target*，但链接文本将是 *title*。"

#: ../../usage/restructuredtext/domains.rst:122
msgid ""
"If you prefix the content with ``!``, no reference/hyperlink will be "
"created."
msgstr "如果你在内容前面加上 ``!``，将不会创建任何参考/超级链接。"

#: ../../usage/restructuredtext/domains.rst:124
msgid ""
"If you prefix the content with ``~``, the link text will only be the last"
" component of the target.  For example, ``:py:meth:`~Queue.Queue.get``` "
"will refer to ``Queue.Queue.get`` but only display ``get`` as the link "
"text."
msgstr ""
"如果你在内容前加上 ``~``，链接文本将只作为目标的最后一个组件。例如，``:py:meth:`~Queue.Queue.get``` 将引用 "
"``Queue.Queue.get`` 但只显示 ``get`` 作为链接文本。"

#: ../../usage/restructuredtext/domains.rst:131
msgid "The Python Domain"
msgstr "Python 域"

#: ../../usage/restructuredtext/domains.rst:133
msgid ""
"The Python domain (name **py**) provides the following directives for "
"module declarations:"
msgstr "Python 域（名称为 **py**）为模块声明提供了以下指令："

#: ../../usage/restructuredtext/domains.rst:138
msgid ""
"This directive marks the beginning of the description of a module (or "
"package submodule, in which case the name should be fully qualified, "
"including the package name).  It does not create content (like e.g. "
":rst:dir:`py:class` does)."
msgstr ""
"这条指令标志着一个模块（或包的子模块，在这种情况下，名称应该是完全限定的，包括包的名称）描述的开始。它不创建内容（比如 "
":rst:dir:`py:class`）。"

#: ../../usage/restructuredtext/domains.rst:143
msgid "This directive will also cause an entry in the global module index."
msgstr "这条指令也会在全局模块索引中引起一个条目。"

#: ../../usage/restructuredtext/domains.rst:146
#: ../../usage/restructuredtext/domains.rst:198
#: ../../usage/restructuredtext/domains.rst:221
#: ../../usage/restructuredtext/domains.rst:246
#: ../../usage/restructuredtext/domains.rst:278
#: ../../usage/restructuredtext/domains.rst:301
#: ../../usage/restructuredtext/domains.rst:327
#: ../../usage/restructuredtext/domains.rst:351
#: ../../usage/restructuredtext/domains.rst:1912
msgid "options"
msgstr "选项"

#: ../../usage/restructuredtext/domains.rst:150
msgid ""
"Indicate platforms which the module is available (if it is available on "
"all platforms, the option should be omitted).  The keys are short "
"identifiers; examples that are in use include \"IRIX\", \"Mac\", "
"\"Windows\" and \"Unix\".  It is important to use a key which has already"
" been used when applicable."
msgstr ""
"指出该模块可用的平台（如果它在所有平台上都可用，该选项应省略）。键是简短的标识符；正在使用的例子包括 "
"\"IRIX\"、\"Mac\"、\"Windows\" 和 \"Unix\"。在适用的情况下，使用已经使用过的键是很重要的。"

#: ../../usage/restructuredtext/domains.rst:159
msgid ""
"Consist of one sentence describing the module's purpose -- it is "
"currently only used in the Global Module Index."
msgstr "由一句话组成，描述该模块的目的 —— 目前只在全局模块索引中使用。"

#: ../../usage/restructuredtext/domains.rst:165
msgid ""
"Mark a module as deprecated; it will be designated as such in various "
"locations then."
msgstr "将一个模块标记为弃用；届时它将在不同的地方被指定为弃用。"

#: ../../usage/restructuredtext/domains.rst:170
msgid ""
"This directive tells Sphinx that the classes, functions etc. documented "
"from here are in the given module (like :rst:dir:`py:module`), but it "
"will not create index entries, an entry in the Global Module Index, or a "
"link target for :rst:role:`py:mod`.  This is helpful in situations where "
"documentation for things in a module is spread over multiple files or "
"sections -- one location has the :rst:dir:`py:module` directive, the "
"others only :rst:dir:`py:currentmodule`."
msgstr ""
"这个指令告诉 Sphinx，从这里记录的类、函数等都在给定的模块中（就像 :rst:dir:`py:module`），但它不会为 "
":rst:role:`py:mod` 创建索引条目、全局模块索引中的条目或一个链接目标。这在一个模块的文档分布在多个文件或部分的情况下很有帮助 "
"—— 一个地方有 :rst:dir:`py:module` 指令，其他地方只有 :rst:dir:`py:currentmodule`。"

#: ../../usage/restructuredtext/domains.rst:178
msgid "The following directives are provided for module and class contents:"
msgstr "为模块和类的内容提供了以下指令："

#: ../../usage/restructuredtext/domains.rst:182
msgid ""
"Describes a module-level function.  The signature should include the "
"parameters as given in the Python function definition, see "
":ref:`signatures`. For example::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:188
msgid "For methods you should use :rst:dir:`py:method`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:190
msgid ""
"The description normally includes information about the parameters "
"required and how they are used (especially whether mutable objects passed"
" as parameters are modified), side effects, and possible exceptions."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:194
msgid ""
"This information can (in any ``py`` directive) optionally be given in a "
"structured form, see :ref:`info-field-lists`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:202
msgid "Indicate the function is an async function."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:209
#: ../../usage/restructuredtext/domains.rst:235
#: ../../usage/restructuredtext/domains.rst:282
#: ../../usage/restructuredtext/domains.rst:315
#: ../../usage/restructuredtext/domains.rst:369
msgid ""
"Describe the location where the object is defined if the object is "
"imported from other modules"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:216
msgid ""
"Describes global data in a module, including both variables and values "
"used as \"defined constants.\"  Class and object attributes are not "
"documented using this environment."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:242
msgid ""
"Describes an exception class.  The signature can, but need not include "
"parentheses with constructor arguments."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:250
#: ../../usage/restructuredtext/domains.rst:290
msgid "Indicate the class is a final class."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:257
msgid ""
"Describes a class.  The signature can optionally include parentheses with"
" parameters which will be shown as the constructor arguments.  See also "
":ref:`signatures`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:261
msgid ""
"Methods and attributes belonging to the class should be placed in this "
"directive's body.  If they are placed outside, the supplied name should "
"contain the class name so that cross-references still work.  Example::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:275
msgid "The first way is the preferred one."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:296
msgid ""
"Describes an object data attribute.  The description should include "
"information about the type of the data to be expected and whether it may "
"be changed directly."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:322
msgid "Describes an object property."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:331
msgid "Indicate the property is abstract."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:336
msgid "Indicate the property is a classmethod."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:345
msgid ""
"Describes an object method.  The parameters should not include the "
"``self`` parameter.  The description should include similar information "
"to that described for ``function``.  See also :ref:`signatures` and :ref"
":`info-field-lists`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:355
msgid "Indicate the method is an abstract method."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:362
msgid "Indicate the method is an async method."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:377
msgid "Indicate the method is a class method."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:384
msgid "Indicate the class is a final method."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:391
msgid "Indicate the method is a property."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:397
msgid "Use :rst:dir:`py:property` instead."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:402
msgid "Indicate the method is a static method."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:409
msgid ""
"Like :rst:dir:`py:method`, but indicates that the method is a static "
"method."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:415
msgid ""
"Like :rst:dir:`py:method`, but indicates that the method is a class "
"method."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:422
msgid ""
"Describes a decorator function.  The signature should represent the usage"
" as a decorator.  For example, given the functions"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:437
msgid "the descriptions should look like this::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:447
msgid "(as opposed to ``.. py:decorator:: removename(func)``.)"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:449
msgid ""
"There is no ``py:deco`` role to link to a decorator that is marked up "
"with this directive; rather, use the :rst:role:`py:func` role."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:455
msgid "Same as :rst:dir:`py:decorator`, but for decorators that are methods."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:457
msgid "Refer to a decorator method using the :rst:role:`py:meth` role."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:462
msgid "Python Signatures"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:464
msgid ""
"Signatures of functions, methods and class constructors can be given like"
" they would be written in Python."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:467
msgid ""
"Default values for optional arguments can be given (but if they contain "
"commas, they will confuse the signature parser).  Python 3-style argument"
" annotations can also be given as well as return type annotations::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:473
msgid ""
"For functions with optional parameters that don't have default values "
"(typically functions implemented in C extension modules without keyword "
"argument support), you can use brackets to specify the optional parts:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:479
msgid "It is customary to put the opening bracket before the comma."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:484
#: ../../usage/restructuredtext/domains.rst:1498
msgid "Info field lists"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:489
msgid "meta fields are added."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:491
msgid ""
"Inside Python object description directives, reST field lists with these "
"fields are recognized and formatted nicely:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:494
msgid ""
"``param``, ``parameter``, ``arg``, ``argument``, ``key``, ``keyword``: "
"Description of a parameter."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:496
msgid "``type``: Type of a parameter.  Creates a link if possible."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:497
msgid ""
"``raises``, ``raise``, ``except``, ``exception``: That (and when) a "
"specific exception is raised."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:499
msgid "``var``, ``ivar``, ``cvar``: Description of a variable."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:500
msgid "``vartype``: Type of a variable.  Creates a link if possible."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:501
#: ../../usage/restructuredtext/domains.rst:688
msgid "``returns``, ``return``: Description of the return value."
msgstr "``returns``、``return``：描述返回值。"

#: ../../usage/restructuredtext/domains.rst:502
msgid "``rtype``: Return type.  Creates a link if possible."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:503
msgid ""
"``meta``: Add metadata to description of the python object.  The metadata"
" will not be shown on output document.  For example, ``:meta private:`` "
"indicates the python object is private member.  It is used in "
":py:mod:`sphinx.ext.autodoc` for filtering members."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:510
msgid ""
"In current release, all ``var``, ``ivar`` and ``cvar`` are represented as"
" \"Variable\".  There is no difference at all."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:513
msgid ""
"The field names must consist of one of these keywords and an argument "
"(except for ``returns`` and ``rtype``, which do not need an argument).  "
"This is best explained by an example::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:531
msgid "This will render like this:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:536
msgid "Send a message to a recipient"
msgstr ""

#: ../../usage/restructuredtext/domains.rst
msgid "参数"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:538
msgid "The person sending the message"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:539
msgid "The recipient of the message"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:540
msgid "The body of the message"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:541
msgid "The priority of the message, can be a number 1-5"
msgstr ""

#: ../../usage/restructuredtext/domains.rst
msgid "返回"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:543
msgid "the message id"
msgstr ""

#: ../../usage/restructuredtext/domains.rst
msgid "返回类型"
msgstr ""

#: ../../usage/restructuredtext/domains.rst
msgid "引发"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:545
msgid "if the message_body exceeds 160 characters"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:546
msgid "if the message_body is not a basestring"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:548
msgid ""
"It is also possible to combine parameter type and description, if the "
"type is a single word, like this::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:555
msgid ""
"Container types such as lists and dictionaries can be linked "
"automatically using the following syntax::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:565
msgid ""
"Multiple types in a type field will be linked automatically if separated "
"by the word \"or\"::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:575
msgid "Cross-referencing Python objects"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:577
msgid ""
"The following roles refer to objects in modules and are possibly "
"hyperlinked if a matching identifier is found:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:582
msgid ""
"Reference a module; a dotted name may be used.  This should also be used "
"for package names."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:587
msgid ""
"Reference a Python function; dotted names may be used.  The role text "
"needs not include trailing parentheses to enhance readability; they will "
"be added automatically by Sphinx if the "
":confval:`add_function_parentheses` config value is ``True`` (the "
"default)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:594
msgid "Reference a module-level variable."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:598
msgid ""
"Reference a \"defined\" constant.  This may be a Python variable that is "
"not intended to be changed."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:603
msgid "Reference a class; a dotted name may be used."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:607
msgid ""
"Reference a method of an object.  The role text can include the type name"
" and the method name; if it occurs within the description of a type, the "
"type name can be omitted.  A dotted name may be used."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:613
msgid "Reference a data attribute of an object."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:615
msgid "The role is also able to refer to property."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:619
msgid "Reference an exception.  A dotted name may be used."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:623
msgid ""
"Reference an object of unspecified type.  Useful e.g. as the "
":confval:`default_role`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:628
msgid ""
"The name enclosed in this markup can include a module name and/or a class"
" name. For example, ``:py:func:`filter``` could refer to a function named"
" ``filter`` in the current module, or the built-in function of that name."
"  In contrast, ``:py:func:`foo.filter``` clearly refers to the ``filter``"
" function in the ``foo`` module."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:634
msgid ""
"Normally, names in these roles are searched first without any further "
"qualification, then with the current module name prepended, then with the"
" current module and class name (if any) prepended.  If you prefix the "
"name with a dot, this order is reversed.  For example, in the "
"documentation of Python's :mod:`codecs` module, ``:py:func:`open``` "
"always refers to the built-in function, while ``:py:func:`.open``` refers"
" to :func:`codecs.open`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:641
msgid ""
"A similar heuristic is used to determine whether the name is an attribute"
" of the currently documented class."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:644
msgid ""
"Also, if the name is prefixed with a dot, and no exact match is found, "
"the target is taken as a suffix and all object names with that suffix are"
" searched. For example, ``:py:meth:`.TarFile.close``` references the "
"``tarfile.TarFile.close()`` function, even if the current module is not "
"``tarfile``.  Since this can get ambiguous, if there is more than one "
"possible match, you will get a warning from Sphinx."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:651
msgid ""
"Note that you can combine the ``~`` and ``.`` prefixes: "
"``:py:meth:`~.TarFile.close``` will reference the "
"``tarfile.TarFile.close()`` method, but the visible link caption will "
"only be ``close()``."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:659
msgid "The C Domain"
msgstr "C 域"

#: ../../usage/restructuredtext/domains.rst:661
msgid "The C domain (name **c**) is suited for documentation of C API."
msgstr "C 域（名称为 **c**）适用于 C API 的文档。"

#: ../../usage/restructuredtext/domains.rst:666
msgid "Describes a C struct member or variable. Example signature::"
msgstr "描述了一个 C 结构的成员或变量。签名示例 ::"

#: ../../usage/restructuredtext/domains.rst:670
msgid "The difference between the two directives is only cosmetic."
msgstr "这两个指令之间的区别只是表面上的。"

#: ../../usage/restructuredtext/domains.rst:674
msgid "Describes a C function. The signature should be given as in C, e.g.::"
msgstr "描述了一个 C 语言函数。签名应该按照 C 语言的方式给出，例如 ::"

#: ../../usage/restructuredtext/domains.rst:678
msgid ""
"Note that you don't have to backslash-escape asterisks in the signature, "
"as it is not parsed by the reST inliner."
msgstr "请注意，你不必在签名中反斜线标出星号，因为它不会被 reST 内联程序解析。"

#: ../../usage/restructuredtext/domains.rst:681
msgid ""
"In the description of a function you can use the following info fields "
"(see also :ref:`info-field-lists`)."
msgstr "在一个函数的描述中，你可以使用以下信息字段（也可参见 :ref:`info-field-lists`）。"

#: ../../usage/restructuredtext/domains.rst:684
msgid ""
"``param``, ``parameter``, ``arg``, ``argument``, Description of a "
"parameter."
msgstr "``param``、``parameter``、``arg``、``argument`` 描述一个参数。"

#: ../../usage/restructuredtext/domains.rst:686
msgid ""
"``type``: Type of a parameter, written as if passed to the "
":rst:role:`c:expr` role."
msgstr "``type``：参数的类型，就像传递给 :rst:role:`c:expr` 角色那样写。"

#: ../../usage/restructuredtext/domains.rst:689
msgid ""
"``rtype``: Return type, written as if passed to the :rst:role:`c:expr` "
"role."
msgstr "``rtype``：返回类型，就像传递给 :rst:role:`c:expr` 角色那样写。"

#: ../../usage/restructuredtext/domains.rst:691
#: ../../usage/restructuredtext/domains.rst:1510
msgid ""
"``retval``, ``retvals``: An alternative to ``returns`` for describing the"
" result of the function."
msgstr "``retval``、``retvals``：替代 ``returns``，用于描述函数的结果。"

#: ../../usage/restructuredtext/domains.rst:694
#: ../../usage/restructuredtext/domains.rst:1514
msgid "The ``retval`` field type."
msgstr "``retval`` 字段类型。"

#: ../../usage/restructuredtext/domains.rst:697
#: ../../usage/restructuredtext/domains.rst:842
#: ../../usage/restructuredtext/domains.rst:1279
#: ../../usage/restructuredtext/domains.rst:1918
msgid "For example::"
msgstr "例如 ::"

#: ../../usage/restructuredtext/domains.rst:707
msgid "which renders as"
msgstr "渲染为"

#: ../../usage/restructuredtext/domains.rst:714
msgid "description of the first parameter."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:715
msgid "description of the second parameter."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:716
msgid "a result."
msgstr ""

#: ../../usage/restructuredtext/domains.rst
msgid "Return values"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:717
msgid "under some conditions."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:718
msgid "under some other conditions as well."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:724
msgid ""
"Describes a C macro, i.e., a C-language ``#define``, without the "
"replacement text."
msgstr "描述一个 C 语言的宏，即一个 C 语言的 ``#define``，没有替换文本。"

#: ../../usage/restructuredtext/domains.rst:727
msgid ""
"In the description of a macro you can use the same info fields as for the"
" :rst:dir:`c:function` directive."
msgstr "在宏的描述中，你可以使用与 :rst:dir:`c:function` 指令相同的信息域。"

#: ../../usage/restructuredtext/domains.rst:730
msgid "The function style variant."
msgstr "函数风格的变体。"

#: ../../usage/restructuredtext/domains.rst:735
msgid "Describes a C struct."
msgstr "描述 C 结构。"

#: ../../usage/restructuredtext/domains.rst:741
msgid "Describes a C union."
msgstr "描述 C 联合体。"

#: ../../usage/restructuredtext/domains.rst:747
msgid "Describes a C enum."
msgstr "描述 C 枚举。"

#: ../../usage/restructuredtext/domains.rst:753
msgid "Describes a C enumerator."
msgstr "描述了C 的枚举器。"

#: ../../usage/restructuredtext/domains.rst:760
msgid ""
"Describes a C type, either as a typedef, or the alias for an unspecified "
"type."
msgstr "描述一个 C 类型，可以是一个类型定义，也可以是一个未指定的类型的别名。"

#: ../../usage/restructuredtext/domains.rst:766
msgid "Cross-referencing C constructs"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:768
msgid ""
"The following roles create cross-references to C-language constructs if "
"they are defined in the documentation:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:782
msgid ""
"Reference a C declaration, as defined above. Note that "
":rst:role:`c:member`, :rst:role:`c:data`, and :rst:role:`c:var` are "
"equivalent."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:786
msgid "The var, struct, union, enum, and enumerator roles."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:791
#: ../../usage/restructuredtext/domains.rst:1228
msgid "Anonymous Entities"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:793
msgid ""
"C supports anonymous structs, enums, and unions. For the sake of "
"documentation they must be given some name that starts with ``@``, e.g., "
"``@42`` or ``@data``. These names can also be used in cross-references, "
"though nested symbols will be found even when omitted. The ``@...`` name "
"will always be rendered as **[anonymous]** (possibly as a link)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:801
#: ../../usage/restructuredtext/domains.rst:1238
msgid "Example::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:813
#: ../../usage/restructuredtext/domains.rst:1250
msgid "This will be rendered as:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:823
msgid "Explicit ref: :c:var:`Data.@data.a`. Short-hand ref: :c:var:`Data.a`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:829
#: ../../usage/restructuredtext/domains.rst:1266
msgid "Aliasing Declarations"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:833
msgid ""
"Sometimes it may be helpful list declarations elsewhere than their main "
"documentation, e.g., when creating a synopsis of an interface. The "
"following directive can be used for this purpose."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:839
msgid ""
"Insert one or more alias declarations. Each entity can be specified as "
"they can in the :rst:role:`c:any` role."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:850
#: ../../usage/restructuredtext/domains.rst:1284
#: ../../usage/restructuredtext/domains.rst:1294
msgid "becomes"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:862
#: ../../usage/restructuredtext/domains.rst:1217
#: ../../usage/restructuredtext/domains.rst:1303
msgid "Options"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:865
#: ../../usage/restructuredtext/domains.rst:1306
msgid ""
"Insert nested declarations as well, up to the total depth given. Use 0 "
"for infinite depth and 1 for just the mentioned declaration. Defaults to "
"1."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:873
#: ../../usage/restructuredtext/domains.rst:1314
msgid ""
"Skip the mentioned declarations and only render nested declarations. "
"Requires ``maxdepth`` either 0 or at least 2."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:883
#: ../../usage/restructuredtext/domains.rst:1377
msgid "Inline Expressions and Types"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:888
msgid ""
"Insert a C expression or type either as inline code (``cpp:expr``) or "
"inline text (``cpp:texpr``). For example::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:900
#: ../../usage/restructuredtext/domains.rst:1394
msgid "will be rendered as follows:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:906
msgid "An expression: :c:expr:`a * f(a)` (or as text: :c:texpr:`a * f(a)`)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:908
msgid "A type: :c:expr:`const Data*` (or as text :c:texpr:`const Data*`)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:915
#: ../../usage/restructuredtext/domains.rst:1412
msgid "Namespacing"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:919
msgid ""
"The C language it self does not support namespacing, but it can sometimes"
" be useful to emulate it in documentation, e.g., to show alternate "
"declarations. The feature may also be used to document members of "
"structs/unions/enums separate from their parent declaration."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:924
msgid ""
"The current scope can be changed using three namespace directives.  They "
"manage a stack declarations where ``c:namespace`` resets the stack and "
"changes a given scope."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:928
msgid ""
"The ``c:namespace-push`` directive changes the scope to a given inner "
"scope of the current one."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:931
msgid ""
"The ``c:namespace-pop`` directive undoes the most recent ``c:namespace-"
"push`` directive."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:936
msgid ""
"Changes the current scope for the subsequent objects to the given scope, "
"and resets the namespace directive stack. Note that nested scopes can be "
"specified by separating with a dot, e.g.::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:942
#: ../../usage/restructuredtext/domains.rst:1433
msgid ""
"All subsequent objects will be defined as if their name were declared "
"with the scope prepended. The subsequent cross-references will be "
"searched for starting in the current scope."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:946
msgid "Using ``NULL`` or ``0`` as the scope will change to global scope."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:950
#: ../../usage/restructuredtext/domains.rst:1464
msgid "Change the scope relatively to the current scope. For example, after::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:956
msgid "the current scope will be ``A.B.C.D``."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:960
msgid ""
"Undo the previous ``c:namespace-push`` directive (*not* just pop a "
"scope). For example, after::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:969
msgid "the current scope will be ``A.B`` (*not* ``A.B.C``)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:971
msgid ""
"If no previous ``c:namespace-push`` directive has been used, but only a "
"``c:namespace`` directive, then the current scope will be reset to global"
" scope.  That is, ``.. c:namespace:: A.B`` is equivalent to::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:980
#: ../../usage/restructuredtext/domains.rst:1676
msgid "Configuration Variables"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:982
msgid "See :ref:`c-config`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:988
msgid "The C++ Domain"
msgstr "C++ 域"

#: ../../usage/restructuredtext/domains.rst:990
msgid "The C++ domain (name **cpp**) supports documenting C++ projects."
msgstr "C++ 域（名称为 **cpp**）支持记录 C++ 项目。"

#: ../../usage/restructuredtext/domains.rst:993
msgid "Directives for Declaring Entities"
msgstr "声明实体的指令"

#: ../../usage/restructuredtext/domains.rst:995
msgid ""
"The following directives are available. All declarations can start with a"
" visibility statement (``public``, ``private`` or ``protected``)."
msgstr "以下指令是可用的。所有的声明都可以以可见性声明开始（``public``、``private`` 或 ``protected``）。"

#: ../../usage/restructuredtext/domains.rst:1001
msgid ""
"Describe a class/struct, possibly with specification of inheritance, "
"e.g.,::"
msgstr "描述一个类/结构，可能带有继承性的说明，例如 ::"

#: ../../usage/restructuredtext/domains.rst:1005
msgid ""
"The difference between :rst:dir:`cpp:class` and :rst:dir:`cpp:struct` is "
"only cosmetic: the prefix rendered in the output, and the specifier shown"
" in the index."
msgstr ""
":rst:dir:`cpp:class` 和 :rst:dir:`cpp:struct` "
"之间的区别只是表面上的：输出中呈现的前缀，以及索引中显示的指定符。"

#: ../../usage/restructuredtext/domains.rst:1009
msgid "The class can be directly declared inside a nested scope, e.g.,::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1013
msgid "A class template can be declared::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1017
msgid "or with a line break::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1022
msgid "Full and partial template specialisations can be declared::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1030
msgid "The :rst:dir:`cpp:struct` directive."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1035
msgid "Describe a function or member function, e.g.,::"
msgstr "描述一个函数或成员函数，如 ::"

#: ../../usage/restructuredtext/domains.rst:1061
msgid "Function templates can also be described::"
msgstr "函数模板也可以被描述为 ::"

#: ../../usage/restructuredtext/domains.rst:1066
msgid "and function template specialisations::"
msgstr "和函数模板的专有 ::"

#: ../../usage/restructuredtext/domains.rst:1074
msgid "Describe a variable or member variable, e.g.,::"
msgstr "描述一个变量或成员变量，例如 ::"

#: ../../usage/restructuredtext/domains.rst:1082
msgid "Variable templates can also be described::"
msgstr "变量模板也可以被描述为 ::"

#: ../../usage/restructuredtext/domains.rst:1091
msgid ""
"Describe a type as in a typedef declaration, a type alias declaration, or"
" simply the name of a type with unspecified type, e.g.,::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1106
msgid "A type alias can also be templated::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1111
msgid "The example are rendered as follows."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1115
msgid "A typedef-like declaration of a type."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1119
msgid "Declaration of a type alias with unspecified type."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1123
msgid "Declaration of a type alias."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1132
msgid ""
"Describe a (scoped) enum, possibly with the underlying type specified.  "
"Any enumerators declared inside an unscoped enum will be declared both in"
" the enum scope and in the parent scope.  Examples::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1156
msgid "Describe an enumerator, optionally with its value defined, e.g.,::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1164
msgid "Describe a union."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1170
#: ../../usage/restructuredtext/domains.rst:1323
msgid ""
"The support for concepts is experimental. It is based on the current "
"draft standard and the Concepts Technical Specification. The features may"
" change as they evolve."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1174
msgid ""
"Describe a concept. It must have exactly 1 template parameter list. The "
"name may be a nested name. Example::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1194
msgid "This will render as follows:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1198
msgid ""
"Proxy to an element of a notional sequence that can be compared, "
"indirected, or incremented."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1201
msgid "**Notation**"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1205
msgid "An lvalue."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1207
msgid "**Valid Expressions**"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1209
msgid ":cpp:expr:`*r`, when :cpp:expr:`r` is dereferenceable."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1210
msgid ""
":cpp:expr:`++r`, with return type :cpp:expr:`It&`, when :cpp:expr:`r` is "
"incrementable."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1219
msgid "Some directives support options:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1221
msgid "``:noindexentry:``, see :ref:`basic-domain-markup`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1222
msgid ""
"``:tparam-line-spec:``, for templated declarations. If specified, each "
"template parameter will be rendered on a separate line."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1230
msgid ""
"C++ supports anonymous namespaces, classes, enums, and unions. For the "
"sake of documentation they must be given some name that starts with "
"``@``, e.g., ``@42`` or ``@data``. These names can also be used in cross-"
"references and (type) expressions, though nested symbols will be found "
"even when omitted. The ``@...`` name will always be rendered as "
"**[anonymous]** (possibly as a link)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1260
msgid ""
"Explicit ref: :cpp:var:`Data::@data::a`. Short-hand ref: "
":cpp:var:`Data::a`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1268
msgid ""
"Sometimes it may be helpful list declarations elsewhere than their main "
"documentation, e.g., when creating a synopsis of a class interface. The "
"following directive can be used for this purpose."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1274
msgid ""
"Insert one or more alias declarations. Each entity can be specified as "
"they can in the :rst:role:`cpp:any` role. If the name of a function is "
"given (as opposed to the complete signature), then all overloads of the "
"function will be listed."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1289
msgid "whereas::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1321
msgid "Constrained Templates"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1327
msgid "Sphinx does not currently support ``requires`` clauses."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1330
msgid "Placeholders"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1332
msgid ""
"Declarations may use the name of a concept to introduce constrained "
"template parameters, or the keyword ``auto`` to introduce unconstrained "
"template parameters::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1346
msgid "Template Introductions"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1348
msgid ""
"Simple constrained function or class templates can be declared with a "
"`template introduction` instead of a template parameter list::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1361
msgid "They are rendered as follows."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1365
msgid ""
"A function template with a template parameter constrained to be an "
"Iterator."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1369
msgid ""
"A class template with a template parameter constrained to be "
"LessThanComparable."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1372
msgid ""
"Note however that no checking is performed with respect to parameter "
"compatibility. E.g., ``Iterator{A, B, C}`` will be accepted as an "
"introduction even though it would not be valid C++."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1382
msgid ""
"Insert a C++ expression or type either as inline code (``cpp:expr``) or "
"inline text (``cpp:texpr``). For example::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1400
msgid "An expression: :cpp:expr:`a * f(a)` (or as text: :cpp:texpr:`a * f(a)`)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1402
msgid ""
"A type: :cpp:expr:`const MySortedContainer<int>&` (or as text "
":cpp:texpr:`const MySortedContainer<int>&`)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1405
msgid "The :rst:role:`cpp:expr` role."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1408
msgid "The :rst:role:`cpp:texpr` role."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1414
msgid ""
"Declarations in the C++ domain are as default placed in global scope.  "
"The current scope can be changed using three namespace directives.  They "
"manage a stack declarations where ``cpp:namespace`` resets the stack and "
"changes a given scope."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1419
msgid ""
"The ``cpp:namespace-push`` directive changes the scope to a given inner "
"scope of the current one."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1422
msgid ""
"The ``cpp:namespace-pop`` directive undoes the most recent ``cpp"
":namespace-push`` directive."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1427
msgid ""
"Changes the current scope for the subsequent objects to the given scope, "
"and resets the namespace directive stack.  Note that the namespace does "
"not need to correspond to C++ namespaces, but can end in names of "
"classes, e.g.,::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1437
msgid ""
"Using ``NULL``, ``0``, or ``nullptr`` as the scope will change to global "
"scope."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1440
msgid "A namespace declaration can also be templated, e.g.,::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1449
msgid ""
"declares ``size`` as a member function of the class template "
"``std::vector``.  Equivalently this could have been declared using::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1457
msgid "or::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1470
msgid "the current scope will be ``A::B::C::D``."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1476
msgid ""
"Undo the previous ``cpp:namespace-push`` directive (*not* just pop a "
"scope). For example, after::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1485
msgid "the current scope will be ``A::B`` (*not* ``A::B::C``)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1487
msgid ""
"If no previous ``cpp:namespace-push`` directive has been used, but only a"
" ``cpp:namespace`` directive, then the current scope will be reset to "
"global scope.  That is, ``.. cpp:namespace:: A::B`` is equivalent to::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1500
msgid ""
"All the C++ directives for declaring entities support the following info "
"fields (see also :ref:`info-field-lists`):"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1503
msgid "``tparam``: Description of a template parameter."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1505
msgid ""
"The :rst:dir:`cpp:function` directive additionally supports the following"
" fields:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1508
msgid ""
"``param``, ``parameter``, ``arg``, ``argument``: Description of a "
"parameter."
msgstr "``param``、``parameter``、``arg``、``argument``：描述一个参数。"

#: ../../usage/restructuredtext/domains.rst:1509
msgid "``returns``, ``return``: Description of a return value."
msgstr "``returns``、``return``：描述一个返回值。"

#: ../../usage/restructuredtext/domains.rst:1512
msgid ""
"`throws`, `throw`, `exception`: Description of a possibly thrown "
"exception."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1520
msgid "Cross-referencing"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1522
msgid "These roles link to the given declaration types:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1535
msgid ""
"Reference a C++ declaration by name (see below for details).  The name "
"must be properly qualified relative to the position of the link."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1538
msgid ""
"The :rst:role:`cpp:struct` role as alias for the :rst:role:`cpp:class` "
"role."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1542
msgid "Note on References with Templates Parameters/Arguments"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1544
msgid ""
"These roles follow the Sphinx :ref:`xref-syntax` rules. This means care "
"must be taken when referencing a (partial) template specialization, e.g. "
"if the link looks like this: ``:cpp:class:`MyClass<int>```. This is "
"interpreted as a link to ``int`` with a title of ``MyClass``. In this "
"case, escape the opening angle bracket with a backslash, like this: "
"``:cpp:class:`MyClass\\<int>```."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1551
msgid ""
"When a custom title is not needed it may be useful to use the roles for "
"inline expressions, :rst:role:`cpp:expr` and :rst:role:`cpp:texpr`, where"
" angle brackets do not need escaping."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1556
msgid "Declarations without template parameters and template arguments"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1558
msgid ""
"For linking to non-templated declarations the name must be a nested name,"
" e.g., ``f`` or ``MyClass::f``."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1563
msgid "Overloaded (member) functions"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1565
msgid ""
"When a (member) function is referenced using just its name, the reference"
" will point to an arbitrary matching overload. The :rst:role:`cpp:any` "
"and :rst:role:`cpp:func` roles use an alternative format, which simply is"
" a complete function declaration. This will resolve to the exact matching"
" overload. As example, consider the following class declaration:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1580
msgid "References using the :rst:role:`cpp:func` role:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1582
msgid "Arbitrary overload: ``C::f``, :cpp:func:`C::f`"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1583
msgid "Also arbitrary overload: ``C::f()``, :cpp:func:`C::f()`"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1584
msgid "Specific overload: ``void C::f()``, :cpp:func:`void C::f()`"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1585
msgid "Specific overload: ``void C::f(int)``, :cpp:func:`void C::f(int)`"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1586
msgid "Specific overload: ``void C::f(double)``, :cpp:func:`void C::f(double)`"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1587
msgid ""
"Specific overload: ``void C::f(double) const``, :cpp:func:`void "
"C::f(double) const`"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1590
msgid ""
"Note that the :confval:`add_function_parentheses` configuration variable "
"does not influence specific overload references."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1597
msgid "Templated declarations"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1599
#: ../../usage/restructuredtext/domains.rst:1636
msgid "Assume the following declarations."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1609
msgid ""
"In general the reference must include the template parameter "
"declarations, and template arguments for the prefix of qualified names. "
"For example:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1612
msgid ""
"``template\\<typename TOuter> Wrapper::Outer`` "
"(:cpp:class:`template\\<typename TOuter> Wrapper::Outer`)"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1614
msgid ""
"``template\\<typename TOuter> template\\<typename TInner> "
"Wrapper::Outer<TOuter>::Inner`` (:cpp:class:`template\\<typename TOuter> "
"template\\<typename TInner> Wrapper::Outer<TOuter>::Inner`)"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1617
msgid ""
"Currently the lookup only succeed if the template parameter identifiers "
"are equal strings.  That is, ``template\\<typename UOuter> "
"Wrapper::Outer`` will not work."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1621
msgid ""
"As a shorthand notation, if a template parameter list is omitted, then "
"the lookup will assume either a primary template or a non-template, but "
"not a partial template specialisation. This means the following "
"references work as well:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1626
msgid "``Wrapper::Outer`` (:cpp:class:`Wrapper::Outer`)"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1628
msgid "``Wrapper::Outer::Inner`` (:cpp:class:`Wrapper::Outer::Inner`)"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1630
msgid ""
"``template\\<typename TInner> Wrapper::Outer::Inner`` "
"(:cpp:class:`template\\<typename TInner> Wrapper::Outer::Inner`)"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1634
msgid "(Full) Template Specialisations"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1653
msgid ""
"In general the reference must include a template parameter list for each "
"template argument list.  The full specialisation above can therefore be "
"referenced with ``template\\<> Outer\\<int>`` (:cpp:class:`template\\<> "
"Outer\\<int>`) and ``template\\<> template\\<> "
"Outer\\<int>::Inner\\<bool>`` (:cpp:class:`template\\<> template\\<> "
"Outer\\<int>::Inner\\<bool>`).  As a shorthand the empty template "
"parameter list can be omitted, e.g., ``Outer\\<int>`` "
"(:cpp:class:`Outer\\<int>`) and ``Outer\\<int>::Inner\\<bool>`` "
"(:cpp:class:`Outer\\<int>::Inner\\<bool>`)."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1663
msgid "Partial Template Specialisations"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1665
msgid "Assume the following declaration."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1670
msgid ""
"References to partial specialisations must always include the template "
"parameter lists, e.g., ``template\\<typename T> Outer\\<T*>`` "
"(:cpp:class:`template\\<typename T> Outer\\<T*>`).  Currently the lookup "
"only succeed if the template parameter identifiers are equal strings."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1678
msgid "See :ref:`cpp-config`."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1683
msgid "The Standard Domain"
msgstr "标准域"

#: ../../usage/restructuredtext/domains.rst:1685
msgid ""
"The so-called \"standard\" domain collects all markup that doesn't "
"warrant a domain of its own.  Its directives and roles are not prefixed "
"with a domain name."
msgstr "所谓的 \"standard\" 域收集了所有不需要有自己的域的标记。它的指令和角色不以域名为前缀。"

#: ../../usage/restructuredtext/domains.rst:1689
msgid ""
"The standard domain is also where custom object descriptions, added using"
" the :func:`~sphinx.application.Sphinx.add_object_type` API, are placed."
msgstr ""
"标准域也是使用 :func:`~sphinx.application.Sphinx.add_object_type` API "
"添加的自定义对象描述的地方。"

#: ../../usage/restructuredtext/domains.rst:1692
msgid "There is a set of directives allowing documenting command-line programs:"
msgstr "有一套允许记录命令行程序的指令："

#: ../../usage/restructuredtext/domains.rst:1696
msgid ""
"Describes a command line argument or switch.  Option argument names "
"should be enclosed in angle brackets.  Examples::"
msgstr "描述了一个命令行参数或开关。选项参数名称应该用角括号括起来。示例 ::"

#: ../../usage/restructuredtext/domains.rst:1707
msgid ""
"The directive will create cross-reference targets for the given options, "
"referenceable by :rst:role:`option` (in the example case, you'd use "
"something like ``:option:`dest_dir```, ``:option:`-m```, or "
"``:option:`--module```)."
msgstr ""
"该指令将为给定的选项创建交叉引用目标，可通过 :rst:role:`option` 来引用（在例子中，你会使用 "
"``:option:`dest_dir``、``:option:`-m``` 或 ``:option:`--module```）。"

#: ../../usage/restructuredtext/domains.rst:1711
msgid ""
"``cmdoption`` directive is a deprecated alias for the ``option`` "
"directive."
msgstr "``cmdoption`` 指令是 ``option`` 指令的一个废弃的别名。"

#: ../../usage/restructuredtext/domains.rst:1715
msgid ""
"Describes an environment variable that the documented code or program "
"uses or defines.  Referenceable by :rst:role:`envvar`."
msgstr "描述文档中的代码或程序使用或定义的环境变量。可以通过 :rst:role:`envvar` 来引用。"

#: ../../usage/restructuredtext/domains.rst:1720
msgid ""
"Like :rst:dir:`py:currentmodule`, this directive produces no output. "
"Instead, it serves to notify Sphinx that all following :rst:dir:`option` "
"directives document options for the program called *name*."
msgstr ""
"和 :rst:dir:`py:currentmodule` 一样，这个指令不产生输出。相反，它的作用是通知 Sphinx，所有下面的 "
":rst:dir:`option` 指令都记录了名为 *name* 的程序的选项。"

#: ../../usage/restructuredtext/domains.rst:1724
msgid ""
"If you use :rst:dir:`program`, you have to qualify the references in your"
" :rst:role:`option` roles by the program name, so if you have the "
"following situation ::"
msgstr ""
"如果你使用 :rst:dir:`program`，你必须在你的 :rst:role:`option` "
"角色中用程序名称来限定引用，所以如果你有以下情况 ::"

#: ../../usage/restructuredtext/domains.rst:1740
msgid ""
"then ``:option:`rm -r``` would refer to the first option, while "
"``:option:`svn -r``` would refer to the second one."
msgstr "那么 ``:option:`rm -r`` 将指第一个选项，而 ``:option:`svn -r``` 将指第二个选项。"

#: ../../usage/restructuredtext/domains.rst:1743
msgid ""
"If ``None`` is passed to the argument, the directive will reset the "
"current program name."
msgstr "如果 ``None`` 被传递给参数，该指令将重置当前的程序名称。"

#: ../../usage/restructuredtext/domains.rst:1746
msgid ""
"The program name may contain spaces (in case you want to document "
"subcommands like ``svn add`` and ``svn commit`` separately)."
msgstr "程序名称可以包含空格（以备你想单独记录子命令，如 ``svn add`` 和 ``svn commit``）。"

#: ../../usage/restructuredtext/domains.rst:1751
msgid ""
"There is also a very generic object description directive, which is not "
"tied to any domain:"
msgstr "还有一个非常通用的对象描述指令，它不与任何域相联系："

#: ../../usage/restructuredtext/domains.rst:1757
msgid ""
"This directive produces the same formatting as the specific ones provided"
" by domains, but does not create index entries or cross-referencing "
"targets. Example::"
msgstr "该指令产生的格式与域所提供的特定格式相同，但不创建索引条目或交叉引用目标。例如 ::"

#: ../../usage/restructuredtext/domains.rst:1767
msgid "The JavaScript Domain"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1769
msgid "The JavaScript domain (name **js**) provides the following directives:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1773
msgid ""
"This directive sets the module name for object declarations that follow "
"after. The module name is used in the global module index and in cross "
"references. This directive does not create an object heading like "
":rst:dir:`py:class` would, for example."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1778
msgid ""
"By default, this directive will create a linkable entity and will cause "
"an entry in the global module index, unless the ``noindex`` option is "
"specified.  If this option is specified, the directive will only update "
"the current module name."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1787
msgid ""
"Describes a JavaScript function or method.  If you want to describe "
"arguments as optional use square brackets as :ref:`documented "
"<signatures>` for Python signatures."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1791
msgid ""
"You can use fields to give more details about arguments and their "
"expected types, errors which may be thrown by the function, and the value"
" being returned::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1805
#: ../../usage/restructuredtext/domains.rst:1834
msgid "This is rendered as:"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1809
msgid "An URI to the location of the resource."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1810
msgid "Gets called with the object."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1811
msgid ""
"Gets called in case the request fails. And a lot of other text so we need"
" multiple lines."
msgstr ""

#: ../../usage/restructuredtext/domains.rst
msgid "抛出"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1814
msgid "For whatever reason in that case."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1815
msgid "Something."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1819
msgid ""
"This directive is an alias for :rst:dir:`js:function`, however it "
"describes a function that is implemented as a method on a class object."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1826
msgid ""
"Describes a constructor that creates an object.  This is basically like a"
" function but will show up with a `class` prefix::"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1838
msgid "The name of the animal"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1839
msgid "an optional age for the animal"
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1843
msgid "Describes a global variable or constant."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1847
msgid "Describes the attribute *name* of *object*."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1851
#: ../../usage/restructuredtext/domains.rst:1943
msgid "These roles are provided to refer to the described objects:"
msgstr "提供这些角色是为了指代所描述的对象："

#: ../../usage/restructuredtext/domains.rst:1862
msgid "The reStructuredText domain"
msgstr "reStructuredText 域"

#: ../../usage/restructuredtext/domains.rst:1864
msgid ""
"The reStructuredText domain (name **rst**) provides the following "
"directives:"
msgstr "reStructuredText 域（名称为 **rst**）提供以下指令："

#: ../../usage/restructuredtext/domains.rst:1868
msgid ""
"Describes a reST directive.  The *name* can be a single directive name or"
" actual directive syntax (`..` prefix and `::` suffix) with arguments "
"that will be rendered differently.  For example::"
msgstr ""
"描述了一个 reST 指令。*name* 可以是一个单一的指令名称或实际的指令语法（`..` 前缀和 `::` 后缀），其参数将被不同地呈现。 "
"例如 ::"

#: ../../usage/restructuredtext/domains.rst:1880
#: ../../usage/restructuredtext/domains.rst:1902
#: ../../usage/restructuredtext/domains.rst:1935
msgid "will be rendered as:"
msgstr "将被渲染为："

#: ../../usage/restructuredtext/domains.rst:1884
#: ../../usage/restructuredtext/domains.rst:1939
msgid "Foo description."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1888
msgid "Bar description."
msgstr ""

#: ../../usage/restructuredtext/domains.rst:1892
msgid ""
"Describes an option for reST directive.  The *name* can be a single "
"option name or option name with arguments which separated with colon "
"(``:``). For example::"
msgstr "描述了 reST 指令的一个选项。*name* 可以是一个单独的选项名称，也可以是带有参数的选项名称，用冒号（``:``）分开。例如 ::"

#: ../../usage/restructuredtext/domains.rst:1916
msgid "Describe the type of option value."
msgstr "描述 选项 值的类型。"

#: ../../usage/restructuredtext/domains.rst:1929
msgid "Describes a reST role.  For example::"
msgstr "描述了一个 reST 角色。比如说 ::"

#: ../../usage/restructuredtext/domains.rst:1951
msgid "The Math Domain"
msgstr "数学域"

#: ../../usage/restructuredtext/domains.rst:1953
msgid "The math domain (name **math**) provides the following roles:"
msgstr "数学域（名称为 **math**）提供了以下 角色："

#: ../../usage/restructuredtext/domains.rst:1957
msgid ""
"Role for cross-referencing equations defined by :rst:dir:`math` directive"
" via their label.  Example::"
msgstr "用于通过标签交叉引用由 :rst:dir:`math` 指令定义的方程的角色。例如 ::"

#: ../../usage/restructuredtext/domains.rst:1969
msgid "More domains"
msgstr "更多域"

#: ../../usage/restructuredtext/domains.rst:1971
msgid ""
"The sphinx-contrib_ repository contains more domains available as "
"extensions; currently Ada_, CoffeeScript_, Erlang_, HTTP_, Lasso_, "
"MATLAB_, PHP_, and Ruby_ domains. Also available are domains for "
"`Chapel`_, `Common Lisp`_, dqn_, Go_, Jinja_, Operation_, and Scala_."
msgstr ""
"sphinx-contrib_ 仓库包含了更多可作为扩展的域；目前有 "
"Ada_、CoffeeScript_、Erlang_、HTTP_、Lasso_、MATLAB_、PHP_ 和 Ruby_ 域。另外还有 "
"`Chapel`_、`Common Lisp`_、dqn_、Go_、Jinja_、Operation_ 和 Scala_ 等域。"

#~ msgid "参数"
#~ msgstr ""

#~ msgid "返回"
#~ msgstr ""

#~ msgid "返回类型"
#~ msgstr ""

#~ msgid "引发"
#~ msgstr ""

#~ msgid "抛出"
#~ msgstr ""

#~ msgid "retval NULL"
#~ msgstr ""

#~ msgid "Parameters"
#~ msgstr ""

#~ msgid "Returns"
#~ msgstr ""

#~ msgid "Return type"
#~ msgstr ""

#~ msgid "Raises"
#~ msgstr ""

#~ msgid "Arguments"
#~ msgstr ""

#~ msgid "Throws"
#~ msgstr ""

#~ msgid "Return values"
#~ msgstr ""

